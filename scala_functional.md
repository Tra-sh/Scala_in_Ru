# Scala Functional

## Функции и методы (идеологически)

- Функции не имеют контекста и не изменяют состояния.
- Методы служат для изменения состояния контекста.

## Функции просто

- Функция — это объект, имеющий метод `.apply()`.
- Все эти `Function0 .. Function22` — это `trait` с абстрактным методом `apply`, типы аргументов и возвращаемого значения у этого метода уже выглядят адекватно.
- `x:Function1[Int, String]` это `new Function1[Int, String] { def apply(x:Int):String = "some_string" }`
- Функция, принимающая 22 параметра, имеет тип `Function22`
- Тип `:Function0[Int]` может быть описан как `:() => Int`
- параметр, переданный функции, нельзя изменить

## Функции глубже

- List - это функция. Которая принимает индекс и возвращает данные. Map - аналогично.
- На самом деле нихуя. List - это class и object. У каждого есть метод apply. метод объекта возвращает экземпляр класса, а метод класса возвращает элемент по указанному адресу.
- Чтобы описывать функцию через wildcards, Нужно чётко объявить тип данных. Либо объявлять тип даннх в телефункции для каждой wildcard, но это пиздец... Без объявления колбеки с wildcard можно скармливать, к примеру, `.map()` у коллекции
- Будучи объявленной как `val` функция может быть передана куда-нибудь еще. А вот ref на метод не получится сделать и никуда чужой метод как параметр не передать. Но Scala умеет принимать метод в качестве параметра и конвертировать его в функцию. Это называется **lifting** *(предполагаю, объявить функцию как val и передавать её туда-сюда, а метод будет доступен через замыкание)*.
- Метод можно конвертировать в функцию: `val f = objName.defName _`. Это пример partial apply (такую же технику можно использовать и с функциями, разумеется). Если `_` является последним, его можно опустить. И присваивать переменной не обязательно.

## Аргументы

- переменный список аргументов для функции/метода поддерживается языком. Например: `args:Int*` (scala.collection.Seq) (а вообще-то WrappedArray). Таким образом для функции/метода это будет один параметр.
- А развернуть коллекцию в аргументы при вызове такой функции можно как `someList:_*`. Типа spread.

## Какие-то выводы о функциональном стиле

- **Функтор** - это хрень, у которой реализован метод `.map`, который возвращает сущность того же типа. К ним относятся Array, Promise, Stream, Tree.
- **Монада** - это хрень, у которой реализован метод .`map` `.flatMap` .`filter` .`forEach`.
- **Laziness** - это `value` + `nextValueProducer`. В Scala можно реализовать laziness через `def` вместо `val`.
- **Мемоизация** прежде всего нужна для кеширования. Чтобы средствами языка научить функцию не вычислять дважды одно и то же

## String interpolation

- `s"... $x"`
- `s"... ${x*z}"`
- `s"""${new SomeClass("SomeStringValue")}"""` - используется для экранирования кавычек
- `f"$someIntVal%1.2f"` - взять `someIntVal` и представить как float с точностью 2.
- `f"$$"` выведет `$`

### For

- **For Comprehensions** - это текника составления последовательности. То есть используется возвращаемое for значение, а не способность производить побочные эффекты. Эта техника может взрывать результат точно так же, как и flatMap. В чём-то, наверное, удобнее из-за очевидности (?) и возможности совмещать генерирование и фильтрацию
- Вообще идея `for` вся в управлении последовательностями. `for` производит последовательность. `yield` отдаёт её элемент. Можно сказать `val List2 = for (x <- List1) yield (x + 1)`.
- `<-` можно сделать несколько раз, ага. Scala помножит длину последовательностей. Потому что некая итоговая последовательность такой и должна быть. Таким образом, можно сказать что в Scala никогда не понадобятся вложенные циклы.
- `for ((key, value) <- someMap)`
- `for (i: Int <- 1 to 10)` - генератор. Включает 10
- `for (i: Int <- 1 until 10)` - генератор. Не включает 10


### Zip

- два list можно зипнуть вместе в туплы

### Destruct

- `val (a, b) = someTuple`
- underscore = i don't care

### Laziness

- через `lazy` можно легко применять в момент инициализации значение переменной, которое будет получено позднее.
- не бывает `lazy var`
- `lazy val` - это вам не `def`! Значение вычисляется и не изменяется, даже если компоненты этого значения изменятся.

### IF ELSE

- поскольку оно возвращает значение, можно сделать `val x = if () ...`, как тернарный оператор в JS.

### Tail Optimized Recursion

- *факториал(100):Int* вернут 0. *факториал(10000):BigInt* вылетит с `StackOverflowException` потому что *recursive methods have limited stack space*
- перед методом можно добавить `@scala.annotation.tailrec`, а можно сочетать `import scala.annotation.tailrec` и `@tailrec`. Для оптимизации нужно, чтобы рекурсивный вызов был последним действием в теле метода. Можно использовать аккумулятор в качестве параметра. Чего-то там еще говорили про `final` для метода, но хз.

### Option, Some, None

- Вообще возвращение Option[] можно рассматривать как упаковку ответа в Map (только лучше).
- `Some("string")` = `Some.apply("string")`. (`Some` — объект. `apply` вернет `Option`)
- тип значения `Some("string")` можно описать как `:Option[String]` или `:Some[String]`
- тип значения `None` можно описать как `:Option[что-то]` или `:Option[Nothing]` или `None.type`
- `Option` имеет метод `get`, который читает содержимое `Some` или даёт exception.
- `Option` имеет метод `getOrElse(другое)`, который либо читает содержимое `Some`, либо вместо этого отдаёт `другое`.
- `option` можно `.map`, `filter`, `filterNot` И т.д. (`None` требует `asInstanceOf`, если в лоб. А вообще лучше паттерн-мэтчить `Some`). Пустой Some становится None.

### Closure

- Вообще правильно обращаться через замыкание к чему-нибудь **immutable**. То есть `val`.

### HOF, callbacks, rocket functions

- `m => m + 1` = `_ + 1` (и с опциями `1+`)

### Каррирование

- смысл состоит в превращении чего угодно в `Function1` (цепочкой).
- `((x:Int, y:Int) => x + y).curried` становится `(x:Int) => (y:Int) => x + y`
- `.uncurried` вернет многоаргументную функцию.
- можно так извращаться над параметрами, которые принимает метод.
- Каррирование нужно компилятору Scala для того, чтобы лучше произвести type inference. Если при работе с составными типами данных есть возможность использовать каррирование, то нужно использовать его. Для HOF. Позволит делать callbacks с underscore без указания типа данных.

### By Value, By Function, By Name Parameters

- Смысл состоит в следующем: параметры, которые принимаются **как значения указанного типа**, вычисляются до того, как код начнёт их использовать.
- Параметры, принимаемые как функция, вычисляются по мере использования. Но передавать такие конструкции бывает неудобно.
- By Name - это laziness и простота использования. `(x: => Int)`.
- Laziness позволяет даже вычисление простого Int при передаче завернуть в блок, а до выполнения обернуть в try/cetch в другом месте.

### `.flatMap`

- вообще это `.map.flatten`.
- Удобно делать из элемента структурку и разбивать её тут же.
- Ещё веселее `set.flatMap`. 
- Можно обойти коллекцию Option и оставить в ней только Some.

### `.withFilter`

- Lazy. ПОтому эффективен. То есть вроде как не обходит последовательность.

## Параллелизм

### Параллельные коллекции

- `par` бывает `Range` и другие.
- `par` возвращает параллельную коллекцию, `seq`— последовательную.
- Задействуются все ядра, обходится не по порядку.
