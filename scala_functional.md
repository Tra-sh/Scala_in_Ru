# Какие-то выводы о функциональном стиле

- Ну вроде как функция - это (как бы) объект, имеющий метод `.apply()`. Будучи объявленной как `val` может быть передана куда-нибудь еще. А вот ref на метод не получится сделать и никуда чужой метод как параметр не передать. Метод можно как-то конвертировать в функцию (предполагаю, объявить функцию как val и передавать её туда-сюда, а метод будет доступен через замыкание). Но скала умеет принимать метод в качестве параметра и конвертировать его в функцию. Это называется **lifting**
- List - это функция. Которая принимает индекс и возвращает данные. Map - аналогично.
- Чтобы описывать функцию через wildcards, Нужно чётко объявить тип данных. Либо объявлять тип даннх в телефункции для каждой wildcard, но это пиздец... Без объявления колбеки с wildcard можно скармливать, к примеру, `.map()` у коллекции

- **Функтор** - это хрень, у которой реализован метод `.map()`, который возвращает сущность того же типа. К ним относятся Array, Promise, Stream, Tree.
- **Монада** - это хрень, у которой реализован метод `.flatMap()`. тема кароче.
- **Laziness** - это `value` + `nextValueProducer`. В Scala можно реализовать laziness через `def` вместо `val`.
- **Мемоизация** прежде всего нужна для кеширования. Чтобы средствами языка научить функцию не вычислять дважды одно и то же
- **Каррирование** нужно компилятору Scala для того, чтобы лучше произвести type inference. Если при работе с составными типами данных есть возможность использовать каррирование, то нужно использовать его. Для HOF. Позволит делать callbacks с underscore без указания типа данных.

- переменный список параметров: `args:Int*` (scala.collection.Seq)



## String interpolation

- `s"... $x"`
- `s"... ${x*z}"`
- `s"""${new SomeClass("SomeStringValue")}"""` - используется для экранирования кавычек

### For

- Вообще идея for вся в управлении последовательностями. for производит последовательность. yield отдаёт её элемент
- `<-` можно сделать несколько раз, ага. Scala помножит длину последовательностей. Потому что некая итоговая последовательность такой и должна быть. Таким образом, можно сказать что в Scala никогда не понадобятся вложенные циклы
- `for ((key, value) <- someMap)`
- `for (i: Int <- 1 to 10)` - генератор. Включает 10
- `for (i: Int <- 1 until 10)` - генератор. Не включает 10

### Zip
- два list можно зипнуть вместе в туплы

### Destruct
- `val (a, b) = someTuple`
underscore = i don't care