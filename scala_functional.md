# Какие-то выводы о функциональном стиле

- Ну вроде как функция - это (как бы) объект, имеющий метод `.apply()`. Будучи объявленной как `val` может быть передана куда-нибудь еще. А вот ref на метод не получится сделать и никуда чужой метод как параметр не передать. Метод можно как-то конвертировать в функцию (предполагаю, объявить функцию как val и передавать её туда-сюда, а метод будет доступен через замыкание)
- List - это функция. Которая принимает индекс и возвращает данные. Map - аналогично.
- Чтобы описывать функцию через wildcards, Нужно чётко объявить тип данных. Либо объявлять тип даннх в телефункции для каждой wildcard, но это пиздец... Без объявления колбеки с wildcard можно скармливать, к примеру, `.map()` у коллекции

- **Функтор** - это хрень, у которой реализован метод `.map()`, который возвращает сущность того же типа. К ним относятся Array, Promise, Stream, Tree.
- **Монада** - это хрень, у которой реализован метод `.flatMap()`. тема кароче.
- **Laziness** - это `value` + `nextValueProducer`. В Scala можно реализовать laziness через `def` вместо `val`.
- **Мемоизация** прежде всего нужна для кеширования. Чтобы средствами языка научить функцию не вычислять дважды одно и то же
- **Каррирование** нужно компилятору Scala для того, чтобы лучше произвести type inference. Если при работе с составными типами данных есть возможность использовать каррирование, то нужно использовать его. Для HOF. Позволит делать callbacks с underscore без указания типа данных.

- переменный список параметров: `args:Int*` (scala.collection.Seq)



## String interpolation

- `s"... $x"`
- `s"... ${x*z}"`
- `s"""${new SomeClass("SomeStringValue")}"""` - используется для экранирования кавычек