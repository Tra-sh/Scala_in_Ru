# Язык

## Особенности

### Поводы для использования в проекте

- OO + Functional
- Строгая проверка типов, скрытая за Type Inference
- Option (None/Some) > Failure is an option
- Immutable структуры данных в языке (нет необходимости в маниакальном сокрытии кода только лишь из сображений защиты от перезаписи. Всё является известным, всё является стабильным).
- Laziness в языке
- Можно запихать в Docker и на Heroku
- Параллельные коллекции из коробки, **многоядерность в мобильнике**.

### Подводные камни

- если main не объявить, то ругнется при выполнении. D объекте, потому что main должен быть статическим методом. А вообще можно сделать т.н. **Runner** — `object X extends App`, и тогда сраный метод не понадобится.
- `' '` одинарные кавычки не канают вообще
- `{ }` не означает литерал объекта. Означает `multiline expression`. Последняя строка - возвращаемое значение.
- видимость переменных ограничена `{ }`
- При делении `Int` на `Int` ответ приводится к типу `Int`.
- `(true == 1) // false!`
- `(false == 0) // false!`
- `(1 == 1.0) //true`
- сравнения `===` не существует (существует в библиотеке **ScalaZ**
- иногда источник проблем заключается в том, что `==` не вызывает type error, то есть в принципе позволяет сравнивать разные типы данных)
- `(a: Int, b: Int):Double = a/b` — не означает, что данные будут рассчитаны как `Double`. Означает, что ответ будет выдан как `Double`. Но рассячитан будет как `Int`.
- `someReallyLong.toInt` даст неадекватный результат.
- Импорт будет не работать из-за переменных сред, и можно сразу переходить на SBT кароче. - classpath гипотетически может мешать.
- В том числе, всегда используйте флаг -Xfatal-warnings; *(?)*
- Код может быть написан для компиляции, а может быть написан как скрипт. И определяться нужно заранее.
- `scala` кеширует результаты помпиляции. Это исправляется `scala -nc ...`
- **Unit** возвращается, к примеру, если забыть `=` в объявлении метода


### Рулез

- `(xxx == yyy)` сначала проверяет левую часть на `Null`, а потом вызывает `equals`
- инфиксная нотация позволяет избавиться от нагромождения скобок, но должна использоваться с теми методами, которые не изменяют состояние класса (опущенные скобки заявляют, что нигде тут ничего не поменяется). Можно передать 2 параметра, но придётс брать их в скобки.
- **Right Associative Colons (Right Associativity)** - это как инфиксная нотация, только имя метода можно писать перед именем объекта. Имя метода должно заканчиваться двоеточием. Использовать нужно именно инфиксно. Чаще всего используется в Lists и Streams.
- `lazy val`, а также lazy параметры через `x: => Int`.
- **tail recursion.** Компилятор умеет преобразовать хвостовую рекурсию в цикл так, чтобы стек не использовался. Это предотвращает stack overflow.
- Поддерживаются Named Arguments.
- `(xx) ? yy : zz` - эта тема происходит от того, что ternary operator делает нам expression, а не является только лишь условным. То есть if/else в scala возвращает значение, которое можно записать куда-нибудь или передать. А соответственно, между возвращаемыми значениями не должно быть конфликта типов.
- `scalac` + `javap`
- c `var` и `val` можно использовать пробелы, reserved keywords и вообще чёрт знает что ещё, через косые кавычки (backtick) — как ``` `import` ``` например.

### Правила хорошего тона

- пишешь `if` — пиши `else` (EOP)
- не использовать `null`
- поменьше пользоваться классами
- писать **pure functions**, с постоянным возвращаемым значением от постоянного аргумента, и обойтись без чтения и записи сайд-эффектов.
- не использовать `var` и **mutable values**
- использовать `.copy`

### REPL

- `:load xx.scala`, а там уже вызывать методы классов.
- `:replay` выполняет все операции сессии работы с REPL заново.

### Scalac

- `scalac -Xprint:all` выводит максимум информации о ходе компиляции
- `scalac -Xshow-phases`

### Scala evaluates everyting

- поэтому `bind()` для передачи параметров колбекам не нужен (так ли?)
- поэтому метод можно объявить как метод без параметров и читать как свойство
- поэтому метод можно вызвать без скобок

### Сравнение Scala с другими языками

- Scala предпочитает immutable (похожие: _, непохожие: JS, Java)
- Scala имеет lazy (похожие: _, непохожие: _)
- Scala имеет замыкания (похожие: _, непохожие: _)

## Начало работы

### DEV-окружение

- **SBT** (выполняет роль NPM. Можно пройтись по структуре каталогов(?). в директории пректа сначала выполнить `sbt` потом выполнить `run`)
- Scala, ScalaC
- настройка Powershell (подробно описано в **Atomic Scala**)
- Переменная среда classpath, переменные среды java

### DEV-практики

- Писать ассерты (тесты) в отдельных от класса методах

## Синтаксис

### Начало

- `val` - это константы
- `var` - это переменные
- `def` - это объявления функции
- `\n` в строках также работают
