# Язык

## Особенности

### Поводы для использования в проекте

- OO + Functional
- Строгая проверка типов, скрытая за Type Inference
- Option (None/Some) > Failure is an option
- Immutable структуры данных в языке (нет необходимости в маниакальном сокрытии кода только лишь из сображений защиты от перезаписи)
- Laziness в языке
- Можно запихать в Docker и на Heroku

### Подводные камни

- если main в классе не объявить, то ругнется при выполнении
- `' '` одинарные кавычки не канают вообще
- `{ }` не означает литерал объекта. Означает `multiline expression`. Последняя строка - возвращаемое значение.
- видимость переменных ограничена `{ }`
- При делении `Int` на `Int` ответ приводится к типу `Int`.
- `(true == 1) // false!`
- `(false == 0) // false!`
- `(1 == 1.0) //true`
- сравнения `===` не существует (существует в библиотеке **ScalaZ**
- иногда источник проблем заключается в том, что `==` не вызывает type error, то есть в принципе позволяет сравнивать разные типы данных)
- `(a: Int, b: Int):Double = a/b` — не означает, что данные будут рассчитаны как `Double`. Означает, что ответ будет выдан как `Double`. Но рассячитан будет как `Int`.
- Импорт будет не работать из-за переменных сред, и можно сразу переходить на SBT кароче.
- В том числе, всегда используйте флаг -Xfatal-warnings; *(?)*

### Рулез

- `( == )` сначала проверяет левую часть на `Null`, а потом вызывает `equals`
- инфиксная нотация позволяет избавиться от нагромождения скобок, но должна использоваться с теми методами, которые не изменяют состояние класса (опущенные скобки заявляют, что нигде тут ничего не поменяется)
- `lazy val`, а также lazy параметры через `x: => Int`
- `tail recursion`. Компилятор может преобразовать хвостовую рекурсию в цикл так, чтобы стек не использовался. Это предотвращает stack overflow
- можно указать только второй параметр из двух, к примеру ( через `prop = val`)
- `(xx) ? yy : zz` - эта тема происходит от того, что ternary operator делает нам expression, а не является только лишь условным. То есть if/else в scala возвращает значение, которое можно записать куда-нибудь или передать. А соответственно, между возвращаемыми значениями не должно быть конфликта типов.
- `scalac` + `javap`

### REPL

- `:load xx.scala`, а там уже вызывать методы классов.
- `:replay` выполняет все операции сессии работы с REPL заново.

### Scala evaluates everyting

- поэтому `bind()` для передачи параметров колбекам не нужен (так ли?)
- поэтому метод можно объявить как метод без параметров и читать как свойство
- поэтому метод можно вызвать без скобок

### Сравнение Scala с другими языками

- Scala предпочитает immutable (похожие, непохожие)
- Scala имеет lazy (похожие, непохожие)
- Scala имеет замыкания (похожие, непохожие)

## Начало работы

### DEV-окружение

- **SBT** (выполняет роль NPM. Можно пройтись по структуре каталогов(?). в директории пректа сначала выполнить `sbt` потом выполнить `run`)
- Scala, ScalaC
- настройка Powershell (подробно описано в **Atomic Scala**)
- Переменная среда classpath, переменные среды java

### DEV-практики

- Писать ассерты (тесты) в отдельных от класса методах

## Синтаксис

### Начало

- `val` - это константы
- `var` - это переменные
- `def` - это объявления функции
- `"""` - тройные кавычки определяют многострочный `String`, включая переносы строк
- `\n` в строках также работают

### Функции и методы - особенности и различия

- идеологически, функции и методы - это разные вещи. Функция не изменяет состояния
- параметр, переданный функции, нельзя изменить
- Функция, принимающая 22 параметра, имеет тип `Function22`



