# Язык

## Подводные камни

- если main в классе не объявить, то ругнется при выполнении
- `' '` одинарные кавычки не канают вообще
- `{ }` не означает литерал объекта. Означает `multiline expression`. Последняя строка - возвращаемое значение.
- видимость переменных ограничена `{ }`
- При делении Int на Int ответ приводится к типу Int.
- `(true == 1) // false!`
- `(false == 0) // false!`
- `(1 == 1.0) //true`
- сравнения `===` не существует

## DEV-окружение

- SBT (выполняет роль NPM. Можно пройтись по структуре каталогов(?). в директории пректа сначала выполнить `sbt` потом выполнить `run`)
- Scala, ScalaC
- настройка Powershell (подробно описано в Atomic Scala)
- Переменная среда classpath, переменные среды java

## Писать ассерты (тесты) в отдельных от класса методах

## Поводы для использования в проекте

- OO + Functional
- Строгая проверка типов, скрытая за Type Inference
- Option (None/Some) > Failure is an option
- Immutable структуры данных в языке (нет необходимости в маниакальном сокрытии кода только лишь из сображений защиты от перезаписи)
- Laziness в языке
- Можно запихать в Docker и на Heroku

## Рулез

- ( == ) сначала проверяет левую часть на Null, а потом вызывает equals
- инфиксная нотация позволяет избавиться от нагромождения скобок, но должна использоваться с теми методами, которые не изменяют состояние класса (опущенные скобки заявляют, что нигде тут ничего не поменяется)
- `lazy val`, а также lazy параметры через `x: => Int`
- `tail recursion`. Компилятор может преобразовать хвостовую рекурсию в цикл так, чтобы стек не использовался. Это предотвращает stack overflow
- можно указать только второй параметр из двух, к примеру ( через `prop = val`)

## Начало

- `val` - это константы
- `var` - это переменные
- `def` - это объявления функции
- `"""` - тройные кавычки определяют многострочный `String`, включая переносы строк
- `\n` в строках также работают

### Scala evaluates everyting

- поэтому `bind()` для передачи параметров колбекам не нужен (так ли?)
- поэтому метод можно объявить как метод без параметров и читать как свойство
- поэтому метод можно вызвать без скобок



### Функции и методы - особенности и различия

- идеологически, функции и методы - это разные вещи. Функция не изменяет состояния
- параметр, переданный функции, нельзя изменить
- Функция, принимающая 22 параметра, имеет тип `Function22`

### Нативные функции

- `isInstanceOf` - это instanceof
- `asInstanceOf` - это приведение типа к заданному с вероятностью `ClassCastException`

### Классы

- значения, переданные **конструктору** c `val`, легко прочитать как `имя_класса.параметр`. Без `val` доступны будут только классу. 

### `case`-классы

- не требуют создания экземпляров
- getter-функции уже определены, 
- `equals`, `hashCode`, `toString`
- Создает метод `copy()`. Инстанс можно поменять, если с copy `()` передать новые значения некоторых параметров. Вернет (новый) измененный объект.
- реализует `companion object` автоматом. То есть экземпляр создается без `new`.
- Аналогичен JS-объекту в плане структуры, только immutable.
- ? окружение
- Особо полезен в `Pattern matching` (Вообще весь pattern-matching это `x match {case "value" | "more_value" => "response"}`)

### Трейты

- (как будто бы интерфейсы/миксины/методы прототипа)
- Хороши для (множественного) определения поведения
- Очень хороши для реализации логгеров. Проще 1 раз написать `with`, чем фигачить все поведение в каждый класс. Пример - библиотека `drizzle`
- Применимы как к классу, так и к `instance`.

### Абстрактные классы

- Хороши для определения структуры

## Типы данных

- Any: 
- AnyVal(всё, у чего есть value, у чего бывают литаралы и scala.Unit), 
- AnyRef (scala.ScalaObject-подобные, java-объекты и String)
- Scala.Null
- Scala.Nothing (child всех, кстати говоря)

## String

- `.mkString` - это как `.join`

## Коллекции

### Map

- `Map ()` позволяет сделать литерал Map.

### List

- nil - это пустой List
- Добавление не хавает ресурсы
- :+ добавляет в конец
- `(List(1,2,3) == List(1,2,3))` true
- `(null == List(1,2,3))` false
- `.size` возвращает количество элементов

### MutableList

- `.clear` очищает mutable list
- `for (i: Int <- 1 to 10)` - генератор.
- `for (item <- sourceList) destMutableList += item * 2` - куда лучше.
- `for (item <- sourceList) yield item * 2` - еще лучше и без побочных эффектов.
- `for (item1 <- sourceList1; item2 <- sourceList2) yield item1 * item2` - вообще охуенно. size = size1*size2. а еще лучше использовать (паттерн) guard.

### Stream

- Это бесконечный List, вычисляемый Lazy
- Могут быть утечки

## Не знаю куда отнести

- как-то там можно использовать views для выборки из результатов работы функции
- return `Option.none` или `Option.some` - в данном случае как будто бы упаковали возвращаемое значение в Map. С которым можно работать очевидно как none и some. То есть Option - это класс.
- `:t` запрашивает тип. как typeof

## TO DO (To learn)

- diamond problem?
- Описать как запускать ебаный проект из IDEA
- apply, unapply? tuples?










