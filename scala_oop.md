# OOP in scala

- когда Scala обеспечивает универсальный доступ, сеттер ` =` превращается в `fieldName_$eq`
- *FP* нехуй писать сеттеры, нужно возвращать новый объект. Реализовать метод `copy`, в котором поля, описывающие состояния, имеют значения по умолчанию, равные текущим — (val someState:Type = this.someState)

## Packages

- Можно вкладывать друг в друга, ага. Вместо того, чтобы жёстко писать имя.

## Import

- Import can be scoped. Даже внутрь класса. Внутрь чего угодно.


## Singleton Object

- `object Name {}`
- Инициализируется 1 раз в момент первого вызова

## Companion (нахуй не нужен)

- Важно понимать, что объект-компаньон не является экземпляром класса. Это другая хуета.
- Позволяет сделать приватным конструктор класса. Чтобы объект-компаньон (фабрика?) был единственным способом добраться до конструктора.
- Реализуется как `class Имя {}` и затем `object Имя {}`, **находящиеся в одном файле**
- Можно импортнуть приватное содержимое `object` внутрь `class` и использовать. А внутри object сделать `private` методы и переменные, которые будут «коллективным сознанием» для всех экземпляров класса. То же верно и наоборот - с помощью метода в компаньоне можно вытащить private значение, переданное конструктору класса, передав ref на объект в качестве аргумента.

## Apply и Unapply

- Apply собирает объект из параметров
- Unapply разбирает объект на параметры. Хорошо для поддержки Pattern Matching
- Вообще-то если метод называется `apply`, то имя метода можно не писать. А просто передать экземпляру аргумент.

## Classes

- хер ты скомпилишь то, что за пределами класса. Интерпретировать - да, можно.
- `private[ClassName]`, `private[com.vendor.package]`, `private[this]`
- `protected[ClassName]`, `protected[com.vendor.package]`, `protected[this]`
- **не уверен, что сюда** префиксный оператор можно задизайнить как `unary_ОПЕРАТОР`.
- В скале есть единственное правило, определяющее приоритет одного оператора в выражении над другим - по первому символу. `спецсимволы`, `* / %`, `+ -`, `:`, `= !`, `< >`, `&`, `^`, `|`, `буквы и цифры`. Например, `((a + b) ^? (c ?^ d)) less ((a ==> b) | c)`

### Constructor

- значения, переданные **конструктору** c `val`, легко прочитать как `имя_класса.параметр`. Без `val` доступны будут только классу.
- Вот создали мы 2 объекта через компаньон, а они не равны друг другу через `==`.

### Auxilary constructor

- **Auxilary constructor** может определяться без `=`, должен вызывать родительский в первой же строке и не может иметь в списке параметров `val` или `var`
- возвращаемые значения игнорируются
- здорово использовать в сочетании с Option[] в главном конструкторе. Тогда вспомогательные передают ему Some или None.
- Один вспомогательный конструктор может вызывать другой. И так вплоть до вызова без параметров.

### `case`-Classes

- Не требуют создания экземпляров
- Реализует `companion object` автоматом. То есть экземпляр создается без `new`.
- Экземпляры равны друг другу *(??? в смысле... вообще все равны? или равные по содержанию равны?)*.
- Реализует `apply` и `unapply` автоматом.
- Не нужно писать `val` для того, чтобы сделать параметр свойством объекта, которое можно прочитать. Scala делает это за меня.
- getter-функции уже определены
- `equals`, `hashCode`, `toString` определены
- Создает метод `copy()`. Инстанс можно поменять, если с `copy()` передать новые значения некоторых параметров. Вернет (новый) измененный объект. Так подразумевается управлять **State**.
- Аналогичен JS-объекту в плане структуры, только immutable.
- ? окружение *(?)*
- case-классы Особо полезны в `Pattern matching` благодаря unapply
- нельзя `case class extends AnotherCaseClass`
- хороши для DTO, вроде того.

### Pattern Matching

- Можно вкладывать друг в друга пока щёки не треснут.
- Вообще весь pattern-matching это `x match {case "value" | "more_value" => "response"}`
- Если не прописать все варианты, можно вылететь с ошибкой. Для этого есть `_` и `None`.
- `=> ()` означает вернуть Unit. То есть ничего не делать.
- `case a => ...` — это присваивание текущего значения выходному параметру `a`, чтобы что-нибудь с ним сделать
- `case A => ...` — сравнение текущего значения с константой `A`, объявленной ранее.
- ```case `a` => ...``` — ??
- `case (i: Int) if i > 5 => ()` так, например, можно поковыряться в методах данного значения

#### Scala regex unapply magic

- `val pattern = "Foo=([0-9]+) Bar=([A-Z]+)".r`
- `//scala.util.matching.Regex = Foo=([0-9]+) Bar=([A-Z]+)`
- `"Foo=123 Bar=ABC" match {
    case pattern(foo, bar) => println("foobar looks like %s-%s".format(foo,bar))}`
- `//foobar looks like 123-ABC`

### Абстрактные классы

- Хороши для определения структуры
- `sealed abstract class` + `case class` = ничего больше в класс не добавить. Тогда можно делать pattern maching, зная все варианты.

### Трейты

- К примеру, **Ordered** - это трейт, происходящий от **Comparable**. Он позволяет применять к данным алгоритмы сортировки, а также содержит методы (как будто операторы) сравнения и compare.
- потенциально более охуенны, чем абстрактные классы (почему и для чего?)
- (как будто бы интерфейсы / миксины / методы прототипа)
- Хороши для (множественного) определения поведения
- Очень хороши для реализации логгеров. Проще 1 раз написать `with`, чем фигачить все поведение в каждый класс. Пример - библиотека `drizzle`
- Применимы как к классу, так и к экземпляру.
- Конфликты override разрешаются в пользу последнего with.
- Однозначно медленнее компилируется, и иногда медленнее исполняется (в сравнении с абстрактными классами)
- Трейты могут иметь companion object
- Трейт может также быть sealed. И это также назовётся алгебраическим типом данных. А наследовать его содержимое в `case object`

## Generics

- Объявляешь составной тип данных как `case class`, указываешь на содержимое private и чтобы тип данных запоминался, хуячишь companion object для доступа к содержимому - всё, ты молодец.
- А если серьёзно, то можно указывать `<:` и `>:` как для контейнера, так и для того, что мы собираемся из него достать/положить, к примеру.
- А вообще очень пиздато делать так: `def doSomething[T](x: T):T`. Так метод вернёт значение того же типа, что и `x` (который может быть любым).
- Пиздато делать также и вот так: `case class Box[T](t:T)`. Коробка такая. А потом можно обратиться к `oneOfTheBoxes.t`. И вообще это можно вкладывать на лету и плодить методы, которые компонуют объекты в составные.

## Type Alias

- указывается `type`. (???)

## Implicit stuff

- Например, позволяет добавить кастомную сортировку для своего типа данных по какому-нибудь вычисляемому признаку

## Beans

- Просьбы для компилятора а-ля `@BeanProperty` не должны использоваться в Scala
- Есть подозрение, что нужно писать граничный тест на Java

## Exceptions

- все exception в Scala - это runtime exception.
- `require(someBoolean, "exception description")` в теле конструктора *работает как PropTypes в React*, выкидывает **IllegalArgumentException**
- в любом месте можно `throw new SomeExceptionType("description")`
- `catch case x:IAE => println(x.getMessage)` - это базовое решение
- `finally` выполняется в любом случае

## Особенности наследования

- использование `override` обязательно при переопределении родительских методов.

## hashCode

- Это имя, которое должен иметь метод, возвращающий некий (32bit Int) hash для экземпляра. Нужно для поддержки структур данных HashMap и HashSet

## Try Catch Exceptions

- `catch` тоже возвращает значение, работает как match в этом случае.
- `case _ : Throwable => 0` Вернет 0 в случае получения любого косячка.