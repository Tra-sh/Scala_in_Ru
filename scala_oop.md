# OOP in scala

## Singleton Object

- `object Name {}`
- Инициализируется 1 раз в момент первого вызова

## Companion (нахуй не нужен)

- Важно понимать, что объект-компаньон не является экземпляром класса. Это другая хуета.
- Хуй его знает зачем он мне нужен. Позволяет сделать приватным конструктор класса. Чтобы объект-компаньон (фабрика?) был единственным способом добраться до конструктора. 
- Реализуется как `class Имя {}` и затем `object Имя {}`, **находящиеся в одном файле**

## Apply и Unapply

- Apply собирает объект из параметров
- Unapply разбирает объект на параметры. Хорошо для поддержки Pattern Matching

## Classes

### Constructor

- значения, переданные **конструктору** c `val`, легко прочитать как `имя_класса.параметр`. Без `val` доступны будут только классу.
- Вот создали мы 2 объекта через компаньон, а они не равны друг другу через `==`.

### Auxilary constructor

- **Auxilary constructor** может определяться без `=`, должен вызывать родительский в первой же строке и не может иметь в списке параметров `val` или `var`
- возвращаемые значения игнорируются


### `case`-Classes

- Не требуют создания экземпляров
- Реализует `companion object` автоматом. То есть экземпляр создается без `new`.
- Экземпляры равны друг другу *(??? в смысле... вообще все равны? или равные по содержанию равны?)*.
- Реализует `apply` и `unapply` автоматом.
- Не нужно писать `val` для того, чтобы сделать параметр свойством объекта, которое можно прочитать. Scala делает это за меня.
- getter-функции уже определены
- `equals`, `hashCode`, `toString` определены
- Создает метод `copy()`. Инстанс можно поменять, если с `copy()` передать новые значения некоторых параметров. Вернет (новый) измененный объект.
- Аналогичен JS-объекту в плане структуры, только immutable.
- ? окружение *(?)*
- case-классы Особо полезны в `Pattern matching` благодаря unapply

### Pattern Matching

- Можно вкладывать друг в друга пока щёки не треснут.
- Вообще весь pattern-matching это `x match {case "value" | "more_value" => "response"}`
- Если не прописать все варианты, можно вылететь с ошибкой. Для этого есть `_` и `None`.
- `=> ()` означает вернуть Unit. То есть ничего не делать.
- `case a => ...` — это присваивание текущего значения выходному параметру `a`, чтобы что-нибудь с ним сделать
- `case A => ...` — сравнение текущего значения с константой `A`, объявленной ранее.
- ```case `a` => ...``` — сравнение текущего значения с константой `a`, объявленной ранее.
- `case (i: Int) if i > 5 => ()`

### Абстрактные классы

- Хороши для определения структуры
- `sealed abstract class` + `case class` = ничего больше в класс не добавить. Тогда можно делать pattern maching, зная все варианты.

### Трейты

- К примеру, **Ordered** - это трейт, происходящий от **Comparable**. Он позволяет применять к данным алгоритмы сортировки, а также содержит методы (как будто операторы) сравнения и compare.
- потенциально более охуенны, чем абстрактные классы (почему и для чего?)
- (как будто бы интерфейсы / миксины / методы прототипа)
- Хороши для (множественного) определения поведения
- Очень хороши для реализации логгеров. Проще 1 раз написать `with`, чем фигачить все поведение в каждый класс. Пример - библиотека `drizzle`
- Применимы как к классу, так и к экземпляру.
- Конфликты override разрешаются в пользу последнего with.
- Однозначно медленнее компилируется, и иногда медленнее исполняется (в сравнении с абстрактными классами)
- Трейты могут иметь companion object
- Трейт может также быть sealed. И это также назовётся алгебраическим типом данных

## Generics

- Объявляешь составной тип данных как `case class`, указываешь на содержимое private и чтобы тип данных запоминался, хуячишь companion object для доступа к содержимому - всё, ты молодец.
- А если серьёзно, то можно указывать `<:` и `>:` как для контейнера, так и для того, что мы собираемся из него достать/положить, к примеру.

## Type Alias

- указывается `type`. (???)

## Implicit stuff

- Например, позволяет добавить кастомную сортировку для своего типа данных по какому-нибудь вычисляемому признаку